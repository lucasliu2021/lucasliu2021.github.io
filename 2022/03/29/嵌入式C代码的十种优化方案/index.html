<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>嵌入式C代码的十种优化方案 | LHAO'S SPACE</title><meta name="author" content="刘良浩"><meta name="copyright" content="刘良浩"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="嵌入式C代码的十种优化方案摘要：代码的优化是有侧重点的，优化是一门平衡的艺术，它往往要以牺牲程序的可读性或者增加代码长度为代价。在嵌入式开发中对程序执行速度的要求比较高，所以学好做好代码优化可以让你的代码执行效率更高。 一、选择合适的算法和数据结构选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令，那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式C代码的十种优化方案">
<meta property="og:url" content="https://lucasliu2021.github.io/2022/03/29/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%81%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/index.html">
<meta property="og:site_name" content="LHAO&#39;S SPACE">
<meta property="og:description" content="嵌入式C代码的十种优化方案摘要：代码的优化是有侧重点的，优化是一门平衡的艺术，它往往要以牺牲程序的可读性或者增加代码长度为代价。在嵌入式开发中对程序执行速度的要求比较高，所以学好做好代码优化可以让你的代码执行效率更高。 一、选择合适的算法和数据结构选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令，那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages5.10qianwan.com%2F10qianwan%2F20210901%2Fb_0_202109012015181047.png&refer=http%3A%2F%2Fimages5.10qianwan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1653643424&t=02e467b160d77678fc9b9617b68043f2">
<meta property="article:published_time" content="2022-03-29T09:35:52.000Z">
<meta property="article:modified_time" content="2022-04-27T09:24:07.306Z">
<meta property="article:author" content="刘良浩">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages5.10qianwan.com%2F10qianwan%2F20210901%2Fb_0_202109012015181047.png&refer=http%3A%2F%2Fimages5.10qianwan.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1653643424&t=02e467b160d77678fc9b9617b68043f2"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://lucasliu2021.github.io/2022/03/29/%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%81%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 刘良浩","link":"链接: ","source":"来源: LHAO'S SPACE","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '嵌入式C代码的十种优化方案',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-27 17:24:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/confidential/"><i class="fa-fw fas fa-folder"></i><span> 机密</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-commenting"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimages5.10qianwan.com%2F10qianwan%2F20210901%2Fb_0_202109012015181047.png&amp;refer=http%3A%2F%2Fimages5.10qianwan.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1653643424&amp;t=02e467b160d77678fc9b9617b68043f2')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LHAO'S SPACE</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/confidential/"><i class="fa-fw fas fa-folder"></i><span> 机密</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/talk/"><i class="fa-fw fas fa-commenting"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">嵌入式C代码的十种优化方案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-29T09:35:52.000Z" title="发表于 2022-03-29 17:35:52">2022-03-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-27T09:24:07.306Z" title="更新于 2022-04-27 17:24:07">2022-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%99%E7%A8%8B/">教程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title="嵌入式C代码的十种优化方案"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="twikoo_visitors"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="嵌入式C代码的十种优化方案"><a href="#嵌入式C代码的十种优化方案" class="headerlink" title="嵌入式C代码的十种优化方案"></a>嵌入式C代码的十种优化方案</h1><p><strong>摘要</strong>：代码的优化是有侧重点的，优化是一门平衡的艺术，它往往要以牺牲程序的可读性或者增加代码长度为代价。在嵌入式开发中对程序执行速度的要求比较高，所以学好做好代码优化可以让你的代码执行效率更高。</p>
<h1 id="一、选择合适的算法和数据结构"><a href="#一、选择合适的算法和数据结构" class="headerlink" title="一、选择合适的算法和数据结构"></a>一、选择合适的算法和数据结构</h1><p>选择一种合适的数据结构很重要，如果在一堆随机存放的数中使用了大量的插入和删除指令，那使用链表要快得多。数组与指针语句具有十分密切的关系，一般来说，指针比较灵活简洁，而数组则比较直观，容易理解。对于大部分的编译器，使用指针比使用数组生成的代码更短，执行效率更高。</p>
<p>在许多种情况下，可以用指针运算代替数组索引，这样做常常能产生又快又短的代码。与数组索引相比，指针一般能使代码速度更快，占用空间更少。使用多维数组时差异更明显。下面的代码作用是相同的，但是效率不一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">数组索引                指针运算</span><br><span class="line"></span><br><span class="line">For(;;)&#123;               p=array</span><br><span class="line"></span><br><span class="line">A=array[t++];          for(;;)&#123;</span><br><span class="line"></span><br><span class="line">                      a=*(p++);</span><br><span class="line"></span><br><span class="line">...............................</span><br><span class="line"></span><br><span class="line">&#125;                      &#125;</span><br></pre></td></tr></table></figure>

<p>指针方法的优点是，array的地址每次装入地址p后，在每次循环中只需对p增量操作。在数组索引方法中，每次循环中都必须根据t值求数组下标的复杂运算。</p>
<h1 id="二、使用尽量小的数据类型"><a href="#二、使用尽量小的数据类型" class="headerlink" title="二、使用尽量小的数据类型"></a>二、使用尽量小的数据类型</h1><p>能够使用字符型(char)定义的变量，就不要使用整型(int)变量来定义；能够使用整型变量定义的变量就不要用长整型(long int)，能不使用浮点型(float)变量就不要使用浮点型变量。当然，在定义变量后不要超过变量的作用范围，如果超过变量的范围赋值，C编译器并不报错，但程序运行结果却错了，而且这样的错误很难发现。</p>
<p>在ICCAVR中，可以在Options中设定使用printf参数，尽量使用基本型参数(%c、%d、%x、%X、%u和%s格式说明符)，少用长整型参数(%ld、%lu、%lx和%lX格式说明符)，至于浮点型的参数(%f)则尽量不要使用，其它C编译器也一样。在其它条件不变的情况下，使用%f参数，会使生成的代码的数量增加很多，执行速度降低。</p>
<h1 id="三、减少运算的强度"><a href="#三、减少运算的强度" class="headerlink" title="三、减少运算的强度"></a>三、减少运算的强度</h1><h2 id="1-查表-游戏程序员必修课"><a href="#1-查表-游戏程序员必修课" class="headerlink" title="1.查表(游戏程序员必修课)"></a><strong>1.查表(游戏程序员必修课)</strong></h2><p>一个聪明的游戏大虾，基本上不会在自己的主循环里搞什么运算工作，绝对是先计算好了，再到循环里查表。看下面的例子：</p>
<p>旧代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long factorial(int i)</span><br><span class="line">&#123;</span><br><span class="line">    if (i == 0)</span><br><span class="line">      return 1;</span><br><span class="line">    else</span><br><span class="line">      return i * factorial(i - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static long factorial_table[] = &#123;1， 1， 2， 6， 24， 120， 720  /* etc */ &#125;;</span><br><span class="line">long factorial(int i)</span><br><span class="line">&#123;</span><br><span class="line">    return factorial_table[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果表很大，不好写，就写一个init函数，在循环外临时生成表格。</p>
<h2 id="2-求余运算"><a href="#2-求余运算" class="headerlink" title="2.求余运算"></a><strong>2.求余运算</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=a%8;</span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=a&amp;7;</span><br></pre></td></tr></table></figure>

<p>说明：位操作只需一个指令周期即可完成，而大部分的C编译器的“%”运算均是调用子程序来完成，代码长、执行速度慢。通常，只要求是求2n方的余数，均可使用位操作的方法来代替。</p>
<h2 id="3-平方运算"><a href="#3-平方运算" class="headerlink" title="3.平方运算"></a><strong>3.平方运算</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=pow(a, 2.0);</span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=a*a;</span><br></pre></td></tr></table></figure>

<p>说明：在有内置硬件乘法器的单片机中(如51系列)，乘法运算比求平方运算快得多，因为浮点数的求平方是通过调用子程序来实现的，在自带硬件乘法器的AVR单片机中，如ATMega163中，乘法运算只需2个时钟周期就可以完成。既使是在没有内置硬件乘法器的AVR单片机中，乘法运算的子程序比平方运算的子程序代码短，执行速度快。</p>
<p>如果是求3次方，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=pow(a，3.0);</span><br></pre></td></tr></table></figure>

<p>更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=a*a*a；</span><br></pre></td></tr></table></figure>

<p>则效率的改善更明显。</p>
<h2 id="4-用移位实现乘除法运算"><a href="#4-用移位实现乘除法运算" class="headerlink" title="4.用移位实现乘除法运算"></a><strong>4.用移位实现乘除法运算</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=a*4;</span><br><span class="line">b=b/4;</span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=a&lt;&lt;2;</span><br><span class="line">b=b&gt;&gt;2;</span><br></pre></td></tr></table></figure>

<p>通常如果需要乘以或除以2n，都可以用移位的方法代替。在ICCAVR中，如果乘以2n，都可以生成左移的代码，而乘以其它的整数或除以任何数，均调用乘除法子程序。用移位的方法得到代码比调用乘除法子程序生成的代码效率高。实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=a*9</span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=(a&lt;&lt;3)+a</span><br></pre></td></tr></table></figure>

<p>采用运算量更小的表达式替换原来的表达式，下面是一个经典例子:</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = w % 8;</span><br><span class="line">y = pow(x， 2.0);</span><br><span class="line">z = y * 33;</span><br><span class="line">for (i = 0;i &lt; MAX;i++)</span><br><span class="line">&#123;</span><br><span class="line">    h = 14 * i;</span><br><span class="line">    printf(&quot;%d&quot;， h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = w &amp; 7;                 /* 位操作比求余运算快*/</span><br><span class="line">y = x * x;                 /* 乘法比平方运算快*/</span><br><span class="line">z = (y &lt;&lt; 5) + y;          /* 位移乘法比乘法快 */</span><br><span class="line">for (i = h = 0; i &lt; MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h += 14;               /* 加法比乘法快 */</span><br><span class="line">    printf(&quot;%d&quot;，h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-避免不必要的整数除法"><a href="#5-避免不必要的整数除法" class="headerlink" title="5.避免不必要的整数除法"></a><strong>5.避免不必要的整数除法</strong></h2><p>整数除法是整数运算中最慢的，所以应该尽可能避免。一种可能减少整数除法的地方是连除，这里除法可以由乘法代替。这个替换的副作用是有可能在算乘积时会溢出，所以只能在一定范围的除法中使用。</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i， j， k， m；</span><br><span class="line">m = i / j / k；</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i， j， k， m；</span><br><span class="line">m = i / (j * k)；</span><br></pre></td></tr></table></figure>

<h2 id="6-使用增量和减量操作符"><a href="#6-使用增量和减量操作符" class="headerlink" title="6.*使用增量和减量操作符*"></a><strong>6.*<em>使用增量和减量操作符*</em></strong></h2><p>在使用到加一和减一操作时尽量使用增量和减量操作符，因为增量符语句比赋值语句更快，原因在于对大多数CPU来说，对内存字的增、减量操作不必明显地使用取内存和写内存的指令，比如下面这条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=x+1;</span><br></pre></td></tr></table></figure>

<p>模仿大多数微机汇编语言为例，产生的代码类似于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">move A，x      ;把x从内存取出存入累加器A</span><br><span class="line">add A，1       ;累加器A加1</span><br><span class="line">store x        ;把新值存回x</span><br></pre></td></tr></table></figure>

<p>如果使用增量操作符，生成的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr x           ;x加1</span><br></pre></td></tr></table></figure>

<p>显然，不用取指令和存指令，增、减量操作执行的速度加快，同时长度也缩短了。</p>
<h2 id="7-使用复合赋值表达式"><a href="#7-使用复合赋值表达式" class="headerlink" title="7.*使用复合赋值表达式*"></a><strong>7.*<em>使用复合赋值表达式*</em></strong></h2><p>复合赋值表达式(如a-&#x3D;1及a+&#x3D;1等)都能够生成高质量的程序代码。</p>
<h2 id="8-提取公共的子表达式"><a href="#8-提取公共的子表达式" class="headerlink" title="8.提取公共的子表达式"></a><strong>8.提取公共的子表达式</strong></h2><p>在某些情况下，C++编译器不能从浮点表达式中提出公共的子表达式，因为这意味着相当于对表达式重新排序。需要特别指出的是，编译器在提取公共子表达式前不能按照代数的等价关系重新安排表达式。这时，程序员要手动地提出公共的子表达式（在VC.NET里有一项“全局优化”选项可以完成此工作，但效果就不得而知了）。</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， d， e， f；</span><br><span class="line">、、、</span><br><span class="line">e = b * c / d；</span><br><span class="line">f = b / d * a；</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， d， e， f；</span><br><span class="line">、、、</span><br><span class="line">const float t(b / d)；</span><br><span class="line">e = c * t；</span><br><span class="line">f = a * t；</span><br></pre></td></tr></table></figure>

<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， e， f；</span><br><span class="line">、、、</span><br><span class="line">e = a / c；</span><br><span class="line">f = b / c；</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， e， f；</span><br><span class="line">、、、</span><br><span class="line">const float t(1.0f / c)；</span><br><span class="line">e = a * t；</span><br><span class="line">f = b * t；</span><br></pre></td></tr></table></figure>

<h1 id="四、结构体成员的布局"><a href="#四、结构体成员的布局" class="headerlink" title="四、结构体成员的布局"></a>四、结构体成员的布局</h1><p>很多编译器有“使结构体字，双字或四字对齐”的选项。但是，还是需要改善结构体成员的对齐，有些编译器可能分配给结构体成员空间的顺序与他们声明的不同。但是，有些编译器并不提供这些功能，或者效果不好。所以，要在付出最少代价的情况下实现最好的结构体和结构体成员对齐，建议采取下列方法：</p>
<h2 id="1-按数据类型的长度排序"><a href="#1-按数据类型的长度排序" class="headerlink" title="1.按数据类型的长度排序"></a><strong>1.按数据类型的长度排序</strong></h2><p>把结构体的成员按照它们的类型长度排序，声明成员时把长的类型放在短的前面。编译器要求把长型数据类型存放在偶数地址边界。在申明一个复杂的数据类型 (既有多字节数据又有单字节数据) 时，应该首先存放多字节数据，然后再存放单字节数据，这样可以避免内存的空洞。编译器自动地把结构的实例对齐在内存的偶数边界。</p>
<h2 id="2-把结构体填充成最长类型长度的整倍数"><a href="#2-把结构体填充成最长类型长度的整倍数" class="headerlink" title="2.把结构体填充成最长类型长度的整倍数"></a><strong>2.把结构体填充成最长类型长度的整倍数</strong></h2><p>把结构体填充成最长类型长度的整倍数。照这样，如果结构体的第一个成员对齐了，所有整个结构体自然也就对齐了。下面的例子演示了如何对结构体成员进行重新排序：</p>
<p>不好的代码，普通顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  char a[5]；</span><br><span class="line">  long k；</span><br><span class="line">  double x；</span><br><span class="line">&#125; baz；</span><br></pre></td></tr></table></figure>

<p>推荐的代码，新的顺序并手动填充了几个字节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct</span><br><span class="line">&#123;</span><br><span class="line">  double x；</span><br><span class="line">  long k；</span><br><span class="line">  char a[5]；</span><br><span class="line">  char pad[7]；</span><br><span class="line">&#125; baz；</span><br></pre></td></tr></table></figure>

<p>这个规则同样适用于类的成员的布局。</p>
<h2 id="3-按数据类型的长度排序本地变量"><a href="#3-按数据类型的长度排序本地变量" class="headerlink" title="3.按数据类型的长度排序本地变量"></a><strong>3.按数据类型的长度排序本地变量</strong></h2><p>当编译器分配给本地变量空间时，它们的顺序和它们在源代码中声明的顺序一样，和上一条规则一样，应该把长的变量放在短的变量前面。如果第一个变量对齐了，其它变量就会连续的存放，而且不用填充字节自然就会对齐。有些编译器在分配变量时不会自动改变变量顺序，有些编译器不能产生4字节对齐的栈，所以4字节可能不对齐。下面这个例子演示了本地变量声明的重新排序：</p>
<p>不好的代码，普通顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short ga， gu， gi；</span><br><span class="line">long foo， bar；</span><br><span class="line">double x， y， z[3]；</span><br><span class="line">char a， b；</span><br><span class="line">float baz；</span><br></pre></td></tr></table></figure>

<p>推荐的代码，改进的顺序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double z[3]；</span><br><span class="line">double x， y；</span><br><span class="line">long foo， bar；</span><br><span class="line">float baz；</span><br><span class="line">short ga， gu， gi；</span><br></pre></td></tr></table></figure>

<h2 id="4-把频繁使用的指针型参数拷贝到本地变量"><a href="#4-把频繁使用的指针型参数拷贝到本地变量" class="headerlink" title="4.把频繁使用的指针型参数拷贝到本地变量"></a><strong>4.把频繁使用的指针型参数拷贝到本地变量</strong></h2><p>避免在函数中频繁使用指针型参数指向的值。因为编译器不知道指针之间是否存在冲突，所以指针型参数往往不能被编译器优化。这样数据不能被存放在寄存器中，而且明显地占用了内存带宽。注意，很多编译器有“假设不冲突”优化开关（在VC里必须手动添加编译器命令行&#x2F;Oa或&#x2F;Ow），这允许编译器假设两个不同的指针总是有不同的内容，这样就不用把指针型参数保存到本地变量。否则，请在函数一开始把指针指向的数据保存到本地变量。如果需要的话，在函数结束前拷贝回去。</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 假设 q != r</span><br><span class="line">void isqrt(unsigned long a， unsigned long* q， unsigned long* r)</span><br><span class="line">&#123;</span><br><span class="line">  *q = a；</span><br><span class="line">  if (a &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    while (*q &gt; (*r = a / *q))</span><br><span class="line">    &#123;</span><br><span class="line">      *q = (*q + *r) &gt;&gt; 1；</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *r = a - *q * *q；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 假设 q != r</span><br><span class="line"></span><br><span class="line">void isqrt(unsigned long a， unsigned long* q， unsigned long* r)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned long qq， rr；</span><br><span class="line">  qq = a；</span><br><span class="line">  if (a &gt; 0)</span><br><span class="line">  &#123;</span><br><span class="line">    while (qq &gt; (rr = a / qq))</span><br><span class="line">    &#123;</span><br><span class="line">      qq = (qq + rr) &gt;&gt; 1；</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rr = a - qq * qq；</span><br><span class="line">  *q = qq；</span><br><span class="line">  *r = rr；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、循环优化"><a href="#五、循环优化" class="headerlink" title="五、循环优化"></a>五、循环优化</h1><h2 id="1-充分分解小的循环"><a href="#1-充分分解小的循环" class="headerlink" title="1*.充分分解小的循环*"></a><strong>1*<em>.充分分解小的循环*</em></strong></h2><p>要充分利用CPU的指令缓存，就要充分分解小的循环。特别是当循环体本身很小的时候，分解循环可以提高性能。注意:很多编译器并不能自动分解循环。不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 3D转化：把矢量 V 和 4x4 矩阵 M 相乘</span><br><span class="line">for (i = 0；i &lt; 4；i ++)</span><br><span class="line">&#123;</span><br><span class="line">  r[i] = 0；</span><br><span class="line">  for (j = 0；j &lt; 4；j ++)</span><br><span class="line">  &#123;</span><br><span class="line">    r[i] += M[j][i]*V[j]；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r[0] = M[0][0]*V[0] + M[1][0]*V[1] + M[2][0]*V[2] + M[3][0]*V[3]；</span><br><span class="line">r[1] = M[0][1]*V[0] + M[1][1]*V[1] + M[2][1]*V[2] + M[3][1]*V[3]；</span><br><span class="line">r[2] = M[0][2]*V[0] + M[1][2]*V[1] + M[2][2]*V[2] + M[3][2]*V[3]；</span><br><span class="line">r[3] = M[0][3]*V[0] + M[1][3]*V[1] + M[2][3]*V[2] + M[3][3]*v[3]；</span><br></pre></td></tr></table></figure>

<h2 id="2-提取公共部分"><a href="#2-提取公共部分" class="headerlink" title="2.提取公共部分"></a><strong>2.提取公共部分</strong></h2><p>对于一些不需要循环变量参加运算的任务可以把它们放到循环外面，这里的任务包括表达式、函数的调用、指针运算、数组访问等，应该将没有必要执行多次的操作全部集合在一起，放到一个init的初始化程序中进行。</p>
<h2 id="3-延时函数"><a href="#3-延时函数" class="headerlink" title="3.延时函数"></a><strong>3.延时函数</strong></h2><p>通常使用的延时函数均采用自加的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void delay (void)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int i;</span><br><span class="line">  for (i=0;i&lt;1000;i++) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其改为自减延时函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void delay (void)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int i;</span><br><span class="line">  for (i=1000;i&gt;0;i--) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个函数的延时效果相似，但几乎所有的C编译对后一种函数生成的代码均比前一种代码少1~ 3个字节，因为几乎所有的MCU均有为0转移的指令，采用后一种方式能够生成这类指令。在使用while循环时也一样，使用自减指令控制循环会比使用自加指令控制循环生成的代码更少1~3个字母。但是在循环中有通过循环变量“i”读写数组的指令时，使用预减循环有可能使数组超界，要引起注意。</p>
<h2 id="4-while循环和do…while循环"><a href="#4-while循环和do…while循环" class="headerlink" title="4.while循环和do…while循环"></a><strong>4.while循环和do…while循环</strong></h2><p>用while循环时有以下两种循环形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i;</span><br><span class="line">i=0;</span><br><span class="line">while (i&lt;1000)</span><br><span class="line">&#123;</span><br><span class="line">   i++;</span><br><span class="line">   //用户程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned int i;</span><br><span class="line">i=1000;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">   i--;</span><br><span class="line">   //用户程序</span><br><span class="line">&#125;</span><br><span class="line">while (i&gt;0);</span><br></pre></td></tr></table></figure>

<p>在这两种循环中，使用do…while循环编译后生成的代码的长度短于while循环。</p>
<h2 id="5-循环展开"><a href="#5-循环展开" class="headerlink" title="5.循环展开"></a><strong>5.循环展开</strong></h2><p>这是经典的速度优化，但许多编译程序(如gcc -funroll-loops)能自动完成这个事，所以现在你自己来优化这个显得效果不明显。</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; 100; i++)</span><br><span class="line">&#123;</span><br><span class="line">  do_stuff(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; 100; )</span><br><span class="line">&#123;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">  do_stuff(i); i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，新代码里比较指令由100次降低为10次，循环时间节约了90%。不过注意:对于中间变量或结果被更改的循环，编译程序往往拒绝展开，(怕担责任呗)，这时候就需要你自己来做展开工作了。</p>
<p>还有一点请注意，在有内部指令cache的CPU上(如MMX芯片)，因为循环展开的代码很大，往往cache溢出，这时展开的代码会频繁地在CPU 的cache和内存之间调来调去，又因为cache速度很高，所以此时循环展开反而会变慢。还有就是循环展开会影响矢量运算优化。</p>
<h2 id="6-循环嵌套"><a href="#6-循环嵌套" class="headerlink" title="6.循环嵌套"></a><strong>6.循环嵌套</strong></h2><p>把相关循环放到一个循环里，也会加快速度。</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; MAX; i++)         /* initialize 2d array to 0&#x27;s */</span><br><span class="line">    for (j = 0; j &lt; MAX; j++)</span><br><span class="line">        a[i][j] = 0.0;</span><br><span class="line">    for (i = 0; i &lt; MAX; i++)        /* put 1&#x27;s along the diagonal */</span><br><span class="line">        a[i][i] = 1.0;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; MAX; i++)         /* initialize 2d array to 0&#x27;s */</span><br><span class="line">&#123;</span><br><span class="line">    for (j = 0; j &lt; MAX; j++)</span><br><span class="line">        a[i][j] = 0.0;</span><br><span class="line">    a[i][i] = 1.0;                            /* put 1&#x27;s along the diagonal */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Switch语句中根据发生频率来进行case排序"><a href="#7-Switch语句中根据发生频率来进行case排序" class="headerlink" title="7.Switch语句中根据发生频率来进行case排序"></a><strong>7.Switch语句中根据发生频率来进行case排序</strong></h2><p>Switch 可能转化成多种不同算法的代码。其中最常见的是跳转表和比较链&#x2F;树。当switch用比较链的方式转化时，编译器会产生if-else-if的嵌套代码，并按照顺序进行比较，匹配时就跳转到满足条件的语句执行。所以可以对case的值依照发生的可能性进行排序，把最有可能的放在第一位，这样可以提高性能。此外，在case中推荐使用小的连续的整数，因为在这种情况下，所有的编译器都可以把switch 转化成跳转表。</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int days_in_month， short_months， normal_months， long_months；</span><br><span class="line">、、、</span><br><span class="line">switch (days_in_month)</span><br><span class="line">&#123;</span><br><span class="line">  case 28:</span><br><span class="line">  case 29:</span><br><span class="line">    short_months ++；</span><br><span class="line">    break；</span><br><span class="line">  case 30:</span><br><span class="line">    normal_months ++；</span><br><span class="line">    break；</span><br><span class="line">  case 31:</span><br><span class="line">    long_months ++；</span><br><span class="line">    break；</span><br><span class="line">  default:</span><br><span class="line">    cout &lt;&lt; &quot;month has fewer than 28 or more than 31 days&quot; &lt;&lt; endl；</span><br><span class="line">    break；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int days_in_month， short_months， normal_months， long_months；</span><br><span class="line">、、、</span><br><span class="line">switch (days_in_month)</span><br><span class="line">&#123;</span><br><span class="line">  case 31:</span><br><span class="line">    long_months ++；</span><br><span class="line">    break；</span><br><span class="line">  case 30:</span><br><span class="line">    normal_months ++；</span><br><span class="line">    break；</span><br><span class="line">  case 28:</span><br><span class="line">  case 29:</span><br><span class="line">    short_months ++；</span><br><span class="line">    break；</span><br><span class="line">  default:</span><br><span class="line">    cout &lt;&lt; &quot;month has fewer than 28 or more than 31 days&quot; &lt;&lt; endl；</span><br><span class="line">    break；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-将大的switch语句转为嵌套switch语句"><a href="#8-将大的switch语句转为嵌套switch语句" class="headerlink" title="8.将大的switch语句转为嵌套switch语句"></a><strong>8.将大的switch语句转为嵌套switch语句</strong></h2><p>当switch语句中的case标号很多时，为了减少比较的次数，明智的做法是把大switch语句转为嵌套switch语句。把发生频率高的case 标号放在一个switch语句中，并且是嵌套switch语句的最外层，发生相对频率相对低的case标号放在另一个switch语句中。比如，下面的程序段把相对发生频率低的情况放在缺省的case标号内。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pMsg=ReceiveMessage();</span><br><span class="line">switch (pMsg-&gt;type)</span><br><span class="line">&#123;</span><br><span class="line">      case FREQUENT_MSG1:</span><br><span class="line">        handleFrequentMsg();</span><br><span class="line">        break;</span><br><span class="line">      case FREQUENT_MSG2:</span><br><span class="line">        handleFrequentMsg2();</span><br><span class="line">        break;</span><br><span class="line">        。。。。。。</span><br><span class="line">      case FREQUENT_MSGn:</span><br><span class="line">        handleFrequentMsgn();</span><br><span class="line">        break;</span><br><span class="line">      default:                     //嵌套部分用来处理不经常发生的消息</span><br><span class="line">        switch (pMsg-&gt;type)</span><br><span class="line">        &#123;</span><br><span class="line">          case INFREQUENT_MSG1:</span><br><span class="line">               handleInfrequentMsg1();</span><br><span class="line">               break;</span><br><span class="line">          case INFREQUENT_MSG2:</span><br><span class="line">               handleInfrequentMsg2();</span><br><span class="line">               break;</span><br><span class="line">        。。。。。。</span><br><span class="line">          case INFREQUENT_MSGm:</span><br><span class="line">              handleInfrequentMsgm();</span><br><span class="line">              break;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果switch中每一种情况下都有很多的工作要做，那么把整个switch语句用一个指向函数指针的表来替换会更加有效，比如下面的switch语句，有三种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum MsgType&#123;Msg1， Msg2， Msg3&#125;</span><br><span class="line">switch (ReceiveMessage()</span><br><span class="line">&#123;</span><br><span class="line">    case Msg1;</span><br><span class="line">        。。。。。。</span><br><span class="line">    case Msg2;</span><br><span class="line">        。。。。。</span><br><span class="line">    case Msg3;</span><br><span class="line">        。。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了提高执行速度，用下面这段代码来替换这个上面的switch语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*准备工作*/</span><br><span class="line">int handleMsg1(void);</span><br><span class="line">int handleMsg2(void);</span><br><span class="line">int handleMsg3(void);</span><br><span class="line">/*创建一个函数指针数组*/</span><br><span class="line">int (*MsgFunction [])()=&#123;handleMsg1， handleMsg2， handleMsg3&#125;;</span><br><span class="line">/*用下面这行更有效的代码来替换switch语句*/</span><br><span class="line">status=MsgFunction[ReceiveMessage()]();</span><br></pre></td></tr></table></figure>

<h2 id="9-循环转置"><a href="#9-循环转置" class="headerlink" title="9.循环转置"></a><strong>9.循环转置</strong></h2><p>有些机器对JNZ(为0转移)有特别的指令处理，速度非常快，如果你的循环对方向不敏感，可以由大向小循环。</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt;= MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">   。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = MAX+1;</span><br><span class="line">while (--i)</span><br><span class="line">&#123;</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过千万注意，如果指针操作使用了i值，这种方法可能引起指针越界的严重错误(i &#x3D; MAX+1;)。当然你可以通过对i做加减运算来纠正，但是这样就起不到加速的作用，除非类似于以下情况：</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char a[MAX+5];</span><br><span class="line">for (i = 1; i &lt;= MAX; i++)</span><br><span class="line">&#123;</span><br><span class="line">  *(a+i+4)=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = MAX+1;</span><br><span class="line">while (--i)</span><br><span class="line">&#123;</span><br><span class="line">    *(a+i+4)=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-公用代码块"><a href="#10-公用代码块" class="headerlink" title="10.公用代码块"></a><strong>10.公用代码块</strong></h2><p>一些公用处理模块，为了满足各种不同的调用需要，往往在内部采用了大量的if-then-else结构，这样很不好，判断语句如果太复杂，会消耗大量的时间的，应该尽量减少公用代码块的使用。(任何情况下，空间优化和时间优化都是对立的–东楼)。当然，如果仅仅是一个(3&#x3D;&#x3D;x)之类的简单判断，适当使用一下，也还是允许的。记住，优化永远是追求一种平衡，而不是走极端。</p>
<h2 id="11-提升循环的性能"><a href="#11-提升循环的性能" class="headerlink" title="11.提升循环的性能"></a><strong>11.提升循环的性能</strong></h2><p>要提升循环的性能，减少多余的常量计算非常有用（比如，不随循环变化的计算）。</p>
<p>不好的代码(在for()中包含不变的if())：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for( i 。。。)</span><br><span class="line">&#123;</span><br><span class="line">  if( CONSTANT0 )</span><br><span class="line">  &#123;</span><br><span class="line">     DoWork0( i )；// 假设这里不改变CONSTANT0的值</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    DoWork1( i )；// 假设这里不改变CONSTANT0的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(CONSTANT0)</span><br><span class="line">&#123;</span><br><span class="line">  for( i 。。。)</span><br><span class="line">  &#123;</span><br><span class="line">    DoWork0( i )；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  for( i 。。。)</span><br><span class="line">  &#123;</span><br><span class="line">    DoWork1( i )；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果已经知道if()的值，这样可以避免重复计算。虽然不好的代码中的分支可以简单地预测，但是由于推荐的代码在进入循环前分支已经确定，就可以减少对分支预测的依赖。</p>
<h2 id="12-选择好的无限循环"><a href="#12-选择好的无限循环" class="headerlink" title="12.选择好的无限循环"></a><strong>12.选择好的无限循环</strong></h2><p>在编程中，我们常常需要用到无限循环，常用的两种方法是while (1)和for (；；)。这两种方法效果完全一样，但那一种更好呢？然我们看看它们编译后的代码：</p>
<p>编译前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while (1)；</span><br></pre></td></tr></table></figure>

<p>编译后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax，1</span><br><span class="line">test eax，eax</span><br><span class="line">je foo+23h</span><br><span class="line">jmp foo+18h</span><br></pre></td></tr></table></figure>

<p>编译前：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (；；)；</span><br></pre></td></tr></table></figure>

<p>编译后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp foo+23h</span><br></pre></td></tr></table></figure>

<p>显然，<code>for (；；)</code>指令少，不占用寄存器，而且没有判断、跳转，比<code>while (1)</code>好。</p>
<h1 id="六、提高CPU的并行性"><a href="#六、提高CPU的并行性" class="headerlink" title="六、提高CPU的并行性"></a>六、提高CPU的并行性</h1><h2 id="1-使用并行代码"><a href="#1-使用并行代码" class="headerlink" title="1.使用并行代码"></a><strong>1.使用并行代码</strong></h2><p>尽可能把长的有依赖的代码链分解成几个可以在流水线执行单元中并行执行的没有依赖的代码链。很多高级语言，包括C++，并不对产生的浮点表达式重新排序，因为那是一个相当复杂的过程。需要注意的是，重排序的代码和原来的代码在代码上一致并不等价于计算结果一致，因为浮点操作缺乏精确度。在一些情况下，这些优化可能导致意料之外的结果。幸运的是，在大部分情况下，最后结果可能只有最不重要的位（即最低位）是错误的。</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double a[100]， sum；</span><br><span class="line">int i；</span><br><span class="line">sum = 0.0f；</span><br><span class="line">for (i=0；i&lt;100；i++)</span><br><span class="line">sum += a[i]；</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">double a[100]， sum1， sum2， sum3， sum4， sum；</span><br><span class="line"></span><br><span class="line">int i；</span><br><span class="line"></span><br><span class="line">sum1 = sum2 = sum3 = sum4 = 0.0；</span><br><span class="line">for (i = 0；i &lt; 100；i += 4)</span><br><span class="line">&#123;</span><br><span class="line">  sum1 += a[i]；</span><br><span class="line">  sum2 += a[i+1]；</span><br><span class="line">  sum3 += a[i+2]；</span><br><span class="line">  sum4 += a[i+3]；</span><br><span class="line">&#125;</span><br><span class="line">sum = (sum4+sum3)+(sum1+sum2)；</span><br></pre></td></tr></table></figure>

<p>要注意的是：使用4路分解是因为这样使用了4段流水线浮点加法，浮点加法的每一个段占用一个时钟周期，保证了最大的资源利用率。</p>
<h2 id="2-避免没有必要的读写依赖"><a href="#2-避免没有必要的读写依赖" class="headerlink" title="2.避免没有必要的读写依赖"></a><strong>2.避免没有必要的读写依赖</strong></h2><p>当数据保存到内存时存在读写依赖，即数据必须在正确写入后才能再次读取。虽然AMD Athlon等CPU有加速读写依赖延迟的硬件，允许在要保存的数据被写入内存前读取出来，但是，如果避免了读写依赖并把数据保存在内部寄存器中，速度会更快。在一段很长的又互相依赖的代码链中，避免读写依赖显得尤其重要。如果读写依赖发生在操作数组时，许多编译器不能自动优化代码以避免读写依赖。所以推荐程序员手动去消除读写依赖，举例来说，引进一个可以保存在寄存器中的临时变量。这样可以有很大的性能提升。下面一段代码是一个例子：</p>
<p>不好的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">float x[VECLEN]， y[VECLEN]， z[VECLEN]；</span><br><span class="line">。。。。。。</span><br><span class="line">for (unsigned int k = 1；k &lt; VECLEN；k ++)</span><br><span class="line">&#123;</span><br><span class="line">  x[k] = x[k-1] + y[k]；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (k = 1；k &lt;VECLEN；k++)</span><br><span class="line">&#123;</span><br><span class="line">  x[k] = z[k] * (y[k] - x[k-1])；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float x[VECLEN]， y[VECLEN]， z[VECLEN]；</span><br><span class="line">。。。。。。</span><br><span class="line">float t(x[0])；</span><br><span class="line">for (unsigned int k = 1；k &lt; VECLEN；k ++)</span><br><span class="line">&#123;</span><br><span class="line">  t = t + y[k]；</span><br><span class="line">  x[k] = t；</span><br><span class="line">&#125;</span><br><span class="line">t = x[0]；</span><br><span class="line">for (k = 1；k &lt;；VECLEN；k ++)</span><br><span class="line">&#123;</span><br><span class="line">  t = z[k] * (y[k] - t)；</span><br><span class="line">  x[k] = t；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、循环不变计算"><a href="#七、循环不变计算" class="headerlink" title="七、循环不变计算"></a>七、循环不变计算</h1><p>对于一些不需要循环变量参加运算的计算任务可以把它们放到循环外面，现在许多编译器还是能自己干这件事，不过对于中间使用了变量的算式它们就不敢动了，所以很多情况下你还得自己干。对于那些在循环中调用的函数，凡是没必要执行多次的操作通通提出来，放到一个init函数里，循环前调用。另外尽量减少喂食次数，没必要的话尽量不给它传参，需要循环变量的话让它自己建立一个静态循环变量自己累加，速度会快一点。</p>
<p>还有就是结构体访问，东楼的经验，凡是在循环里对一个结构体的两个以上的元素执行了访问，就有必要建立中间变量了(结构这样，那C++的对象呢?想想看)，看下面的例子:</p>
<p>旧代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = a-&gt;b-&gt;c[4]-&gt;aardvark + a-&gt;b-&gt;c[4]-&gt;baboon + a-&gt;b-&gt;c[4]-&gt;cheetah + a-&gt;b-&gt;c[4]-&gt;dog;</span><br></pre></td></tr></table></figure>

<p>新代码:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct animals * temp = a-&gt;b-&gt;c[4];</span><br><span class="line">total = temp-&gt;aardvark + temp-&gt;baboon + temp-&gt;cheetah + temp-&gt;dog;</span><br></pre></td></tr></table></figure>

<p>一些老的C语言编译器不做聚合优化，而符合ANSI规范的新的编译器可以自动完成这个优化，看例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， d， f， g;</span><br><span class="line">。。。</span><br><span class="line">a = b / c * d;</span><br><span class="line">f = b * g / c;</span><br></pre></td></tr></table></figure>

<p>这种写法当然要得，但是没有优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">float a， b， c， d， f， g;</span><br><span class="line">。。。</span><br><span class="line">a = b / c * d;</span><br><span class="line">f = b / c * g;</span><br></pre></td></tr></table></figure>

<p>如果这么写的话，一个符合ANSI规范的新的编译器可以只计算b&#x2F;c一次，然后将结果代入第二个式子，节约了一次除法运算。</p>
<h1 id="八、函数优化"><a href="#八、函数优化" class="headerlink" title="八、函数优化"></a>八、函数优化</h1><h2 id="1-Inline函数"><a href="#1-Inline函数" class="headerlink" title="1.Inline函数"></a><strong>1.Inline函数</strong></h2><p>在C++中，关键字Inline可以被加入到任何函数的声明中。这个关键字请求编译器用函数内部的代码替换所有对于指出的函数的调用。这样做在两个方面快于函数调用：第一，省去了调用指令需要的执行时间；第二，省去了传递变元和传递过程需要的时间。但是使用这种方法在优化程序速度的同时，程序长度变大了，因此需要更多的ROM。使用这种优化在Inline函数频繁调用并且只包含几行代码的时候是最有效的。</p>
<h2 id="2-不定义不使用的返回值"><a href="#2-不定义不使用的返回值" class="headerlink" title="2.*不定义不使用的返回值*"></a><strong>2.*<em>不定义不使用的返回值*</em></strong></h2><p>函数定义并不知道函数返回值是否被使用，假如返回值从来不会被用到，应该使用void来明确声明函数不返回任何值。</p>
<h2 id="3-减少函数调用参数"><a href="#3-减少函数调用参数" class="headerlink" title="3.减少函数调用参数"></a><strong>3.减少函数调用参数</strong></h2><p>使用全局变量比函数传递参数更加有效率。这样做去除了函数调用参数入栈和函数完成后参数出栈所需要的时间。然而决定使用全局变量会影响程序的模块化和重入，故要慎重使用。</p>
<h2 id="4-所有函数都应该有原型定义"><a href="#4-所有函数都应该有原型定义" class="headerlink" title="4.所有函数都应该有原型定义"></a><strong>4.所有函数都应该有原型定义</strong></h2><p>一般来说，所有函数都应该有原型定义。原型定义可以传达给编译器更多的可能用于优化的信息。</p>
<h2 id="5-尽可能使用常量-const"><a href="#5-尽可能使用常量-const" class="headerlink" title="5.尽可能使用常量(const)"></a><strong>5.尽可能使用常量(const)</strong></h2><p>尽可能使用常量(const)。C++ 标准规定，如果一个const声明的对象的地址不被获取，允许编译器不对它分配储存空间。这样可以使代码更有效率，而且可以生成更好的代码。</p>
<h2 id="6-把本地函数声明为静态的-static"><a href="#6-把本地函数声明为静态的-static" class="headerlink" title="6.把本地函数声明为静态的(static)"></a><strong>6.把本地函数声明为静态的(static)</strong></h2><p>如果一个函数只在实现它的文件中被使用，把它声明为静态的(static)以强制使用内部连接。否则，默认的情况下会把函数定义为外部连接。这样可能会影响某些编译器的优化——比如，自动内联。</p>
<h1 id="九、采用递归"><a href="#九、采用递归" class="headerlink" title="九、采用递归"></a>九、采用递归</h1><p>与LISP之类的语言不同，C语言一开始就病态地喜欢用重复代码循环，许多C程序员都是除非算法要求，坚决不用递归。事实上，C编译器们对优化递归调用一点都不反感，相反，它们还很喜欢干这件事。只有在递归函数需要传递大量参数，可能造成瓶颈的时候，才应该使用循环代码，其他时候，还是用递归好些。</p>
<h1 id="十、变量"><a href="#十、变量" class="headerlink" title="十、变量"></a>十、变量</h1><p>1.register变量 在声明局部变量的时候可以使用register关键字。这就使得编译器把变量放入一个多用途的寄存器中，而不是在堆栈中，合理使用这种方法可以提高执行速度。函数调用越是频繁，越是可能提高代码的速度。</p>
<p>在最内层循环避免使用全局变量和静态变量，除非你能确定它在循环周期中不会动态变化，大多数编译器优化变量都只有一个办法，就是将他们置成寄存器变量，而对于动态变量，它们干脆放弃对整个表达式的优化。尽量避免把一个变量地址传递给另一个函数，虽然这个还很常用。C语言的编译器们总是先假定每一个函数的变量都是内部变量，这是由它的机制决定的，在这种情况下，它们的优化完成得最好。但是，一旦一个变量有可能被别的函数改变，这帮兄弟就再也不敢把变量放到寄存器里了，严重影响速度。看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = b();</span><br><span class="line">c(&amp;d);</span><br></pre></td></tr></table></figure>

<p>因为d的地址被c函数使用，有可能被改变，编译器不敢把它长时间的放在寄存器里，一旦运行到c(&amp;d)，编译器就把它放回内存，如果在循环里，会造成N次频繁的在内存和寄存器之间读写d的动作，众所周知，CPU在系统总线上的读写速度慢得很。比如你的赛杨300，CPU主频300，总线速度最多66M，为了一个总线读，CPU可能要等4-5个周期，得。。得。。得。。想起来都打颤。</p>
<p>2.同时声明多个变量优于单独声明变量 3.短变量名优于长变量名，应尽量使变量名短一点 4.在循环开始前声明变量</p>
<h1 id="11、使用嵌套的if结构"><a href="#11、使用嵌套的if结构" class="headerlink" title="11、使用嵌套的if结构"></a>11、使用嵌套的if结构</h1><p>在if结构中如果要判断的并列条件较多，最好将它们拆分成多个if结构，然后嵌套在一起，这样可以避免无谓的判断。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">刘良浩</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="/about"><i class="fas fa-user"></i><span>关于我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lucasliu2021" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:519817757@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=519817757&amp;Site=hexun.com/ngdao&amp;Menu=yes" target="_blank" title=""><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/499426727" target="_blank" title=""><i class="fa-brands fa-tv"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果你在使用中遇到问题，请到 Github Issues 或者 留言板 进行反馈。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FC%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8D%81%E7%A7%8D%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">1.</span> <span class="toc-text">嵌入式C代码的十种优化方案</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">一、选择合适的算法和数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E5%B0%BD%E9%87%8F%E5%B0%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">二、使用尽量小的数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%87%8F%E5%B0%91%E8%BF%90%E7%AE%97%E7%9A%84%E5%BC%BA%E5%BA%A6"><span class="toc-number">4.</span> <span class="toc-text">三、减少运算的强度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9F%A5%E8%A1%A8-%E6%B8%B8%E6%88%8F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E4%BF%AE%E8%AF%BE"><span class="toc-number">4.1.</span> <span class="toc-text">1.查表(游戏程序员必修课)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B1%82%E4%BD%99%E8%BF%90%E7%AE%97"><span class="toc-number">4.2.</span> <span class="toc-text">2.求余运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B9%B3%E6%96%B9%E8%BF%90%E7%AE%97"><span class="toc-number">4.3.</span> <span class="toc-text">3.平方运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%A8%E7%A7%BB%E4%BD%8D%E5%AE%9E%E7%8E%B0%E4%B9%98%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.4.</span> <span class="toc-text">4.用移位实现乘除法运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">5.避免不必要的整数除法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%A2%9E%E9%87%8F%E5%92%8C%E5%87%8F%E9%87%8F%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">4.6.</span> <span class="toc-text">6.*使用增量和减量操作符*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.7.</span> <span class="toc-text">7.*使用复合赋值表达式*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E7%9A%84%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">4.8.</span> <span class="toc-text">8.提取公共的子表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98%E7%9A%84%E5%B8%83%E5%B1%80"><span class="toc-number">5.</span> <span class="toc-text">四、结构体成员的布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%95%BF%E5%BA%A6%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.</span> <span class="toc-text">1.按数据类型的长度排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8A%8A%E7%BB%93%E6%9E%84%E4%BD%93%E5%A1%AB%E5%85%85%E6%88%90%E6%9C%80%E9%95%BF%E7%B1%BB%E5%9E%8B%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B4%E5%80%8D%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2.把结构体填充成最长类型长度的整倍数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%95%BF%E5%BA%A6%E6%8E%92%E5%BA%8F%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">5.3.</span> <span class="toc-text">3.按数据类型的长度排序本地变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8A%8A%E9%A2%91%E7%B9%81%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8C%87%E9%92%88%E5%9E%8B%E5%8F%82%E6%95%B0%E6%8B%B7%E8%B4%9D%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">5.4.</span> <span class="toc-text">4.把频繁使用的指针型参数拷贝到本地变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">五、循环优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%85%85%E5%88%86%E5%88%86%E8%A7%A3%E5%B0%8F%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.1.</span> <span class="toc-text">1*.充分分解小的循环*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8F%90%E5%8F%96%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86"><span class="toc-number">6.2.</span> <span class="toc-text">2.提取公共部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BB%B6%E6%97%B6%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">3.延时函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-while%E5%BE%AA%E7%8E%AF%E5%92%8Cdo%E2%80%A6while%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.4.</span> <span class="toc-text">4.while循环和do…while循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BE%AA%E7%8E%AF%E5%B1%95%E5%BC%80"><span class="toc-number">6.5.</span> <span class="toc-text">5.循环展开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">6.6.</span> <span class="toc-text">6.循环嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Switch%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%A0%B9%E6%8D%AE%E5%8F%91%E7%94%9F%E9%A2%91%E7%8E%87%E6%9D%A5%E8%BF%9B%E8%A1%8Ccase%E6%8E%92%E5%BA%8F"><span class="toc-number">6.7.</span> <span class="toc-text">7.Switch语句中根据发生频率来进行case排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B0%86%E5%A4%A7%E7%9A%84switch%E8%AF%AD%E5%8F%A5%E8%BD%AC%E4%B8%BA%E5%B5%8C%E5%A5%97switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">6.8.</span> <span class="toc-text">8.将大的switch语句转为嵌套switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%BE%AA%E7%8E%AF%E8%BD%AC%E7%BD%AE"><span class="toc-number">6.9.</span> <span class="toc-text">9.循环转置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%85%AC%E7%94%A8%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">6.10.</span> <span class="toc-text">10.公用代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%8F%90%E5%8D%87%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">6.11.</span> <span class="toc-text">11.提升循环的性能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%80%89%E6%8B%A9%E5%A5%BD%E7%9A%84%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF"><span class="toc-number">6.12.</span> <span class="toc-text">12.选择好的无限循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%8F%90%E9%AB%98CPU%E7%9A%84%E5%B9%B6%E8%A1%8C%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">六、提高CPU的并行性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%B9%B6%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">1.使用并行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E7%9A%84%E8%AF%BB%E5%86%99%E4%BE%9D%E8%B5%96"><span class="toc-number">7.2.</span> <span class="toc-text">2.避免没有必要的读写依赖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E8%AE%A1%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">七、循环不变计算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">八、函数优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Inline%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">1.Inline函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">9.2.</span> <span class="toc-text">2.*不定义不使用的返回值*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%8F%E5%B0%91%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">3.减少函数调用参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%89%80%E6%9C%89%E5%87%BD%E6%95%B0%E9%83%BD%E5%BA%94%E8%AF%A5%E6%9C%89%E5%8E%9F%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">9.4.</span> <span class="toc-text">4.所有函数都应该有原型定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8%E5%B8%B8%E9%87%8F-const"><span class="toc-number">9.5.</span> <span class="toc-text">5.尽可能使用常量(const)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8A%8A%E6%9C%AC%E5%9C%B0%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA%E9%9D%99%E6%80%81%E7%9A%84-static"><span class="toc-number">9.6.</span> <span class="toc-text">6.把本地函数声明为静态的(static)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E9%87%87%E7%94%A8%E9%80%92%E5%BD%92"><span class="toc-number">10.</span> <span class="toc-text">九、采用递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">11.</span> <span class="toc-text">十、变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%A5%97%E7%9A%84if%E7%BB%93%E6%9E%84"><span class="toc-number">12.</span> <span class="toc-text">11、使用嵌套的if结构</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 刘良浩</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'twikoo-4g9eeh6ya385c919',
      region: 'ap-shanghai',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'twikoo-4g9eeh6ya385c919',
      region: 'ap-shanghai',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo@1/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://lucasliu2021.github.io/categories/教程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 魔改教程 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://lucasliu2021.github.io/categories/学习/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 读书笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://lucasliu2021.github.io/categories/编程/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 编程学习 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://lucasliu2021.github.io/categories/随想/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 胡思乱想 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://lucasliu2021.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style>
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?lucasliu2021";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="lucasliu2021";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>